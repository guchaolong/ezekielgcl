
# 线程

## Java线程的6种状态
新建NEW
<mark style="background: #FF5582A6;">RUNNABLE</mark>：（包括了传统操作系统线程的<mark style="background: #FF5582A6;">就绪ready和运行running两个状态</mark>）
阻塞BLOCKED：等待锁的释放
等待WAITING：调用了wait等方法，释放锁，进入等待状态，需要其他线程唤醒
TIMED_WAITING：超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒
TERMINATED： 终止状态。此时线程已执行完毕
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230808180546.png)



# 并发带来的问题
## 安全性问题：
	1.原子性 （都做，或者都不做，即不会被线程调度机制打断的操作，没有上下文切换）
	2.可见性 
	3.有序性


```java
i = 0; // 操作1 对基本数据类型变量的赋值是原子操作；
i++;   // 操作2 包含三个操作，读取i的值，将i加1，将值赋给i；
i = j; // 操作3 读取j的值，将j的值赋给i；
i = i + 1; // 操作4 包含三个操作，读取i的值，将i加1，将值赋给i；

//只有操作1是原子操作，234都不是原子操作
```



为了解决多线程<mark style="background: #FF5582A6;">可见性</mark>问题，Java语言提供了`volatile`这个关键字。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通共享变量不能保证可见性，因为变量被修改后什么时候刷回到主存是不确定的，另外一个线程读的可能就是旧值。

在Java语言中通过可以使用synchronize或者lock来保证<mark style="background: #FF5582A6;">原子性</mark>和<mark style="background: #FF5582A6;">可见性</mark>。
加锁可以保证在同一时刻只有一个线程在执行同步代码块，释放锁之前会将变量刷回至主存，这样也就保证了可见性

## 活跃性问题
死锁、活锁、饥饿问题

## 性能问题
多线程并发一定比单线程串行执行快吗，答案是不一定，因为多线程有<mark style="background: #D2B3FFA6;">创建线程</mark>和<mark style="background: #D2B3FFA6;">线程上下文切换</mark>的开销

创建线程是直接向系统申请资源的，对操作系统来说创建一个线程的代价是十分昂贵的，需要给它分配内存、列入调度等。

线程创建完之后，还会遇到线程`上下文切换`

一般减少上下文切换的方法有：

- 无锁并发编程：可以参照concurrentHashMap锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。
- <mark style="background: #FFB8EBA6;">CAS算法</mark>，利用Atomic下使用CAS算法来更新数据，使用了<mark style="background: #FFB8EBA6;">乐观锁</mark>，可以有效的减少一部分不必要的锁竞争带来的上下文切换
- 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换


# Java内存模型JMM

JMM不同和Java内存区域不一样
先谈运行时数据区，然后JMM


JMM与Java内存区域划分的区别与联系
上面两小节分别提到了JMM和Java运行时内存区域的划分，这两者既有差别又有联系：
- 区别
    两者是不同的概念层次。JMM是抽象的，他是用来描述<mark style="background: #FF5582A6;">一组规则</mark>，通过这个规则来控制各个变量的访问方式，围绕**原子性、有序性、可见性**等展开的。而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的**内存划分**。
- 联系
    都存在私有数据区域和共享数据区域。一般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。 


线程之间的<mark style="background: #D2B3FFA6;">共享变量</mark>存在<mark style="background: #D2B3FFA6;">主内存</mark>中，每个线程都有一个私有的<mark style="background: #D2B3FFA6;">本地内存</mark>，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等


根据JMM的规定，线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取

**JMM通过控制<mark style="background: #BBFABBA6;">主内存</mark>与每个线程的<mark style="background: #BBFABBA6;">本地内存</mark>之间的交互，来提供内存可见性保证**

Java中的volatile关键字可以保证多线程操作共享变量的<mark style="background: #FF5582A6;">可见性</mark>以及<mark style="background: #FF5582A6;">禁止指令重排序</mark>，synchronized关键字不仅保证<mark style="background: #D2B3FFA6;">可见性</mark>，同时也保证了<mark style="background: #FFB8EBA6;">原子性</mark>（互斥性）。

在更底层，JMM通过<mark style="background: #FFB8EBA6;">内存屏障</mark>来实现内存的<mark style="background: #BBFABBA6;">可见性以及禁止重排序</mark>。为了程序员的方便理解，提出了happens-before，它更加的简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则以及这些规则的具体实现方法。


**指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致**。所以在多线程下，指令重排序可能会导致一些问题


# volatile 
volatile 可以保证可见性，但不保证原子性：

- 当写一个 volatile 变量时，JMM 会把该线程本地内存中的变量强制刷新到主内存中去；
- 这个写操作会导致其他线程中的 volatile 变量缓存无效

重排序需要遵守一定规则：
- 重排序操作不会对<mark style="background: #FF5582A6;">存在数据依赖关系的操作</mark>进行重排序。比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。
- 重排序是为了优化性能，<mark style="background: #FF5582A6;">但是不管怎么重排序，单线程下程序的执行结果不能被改变</mark>。比如：a=1;b=2;c=a+b 这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发生重排序，但是 c=a+b 这个操作是不会被重排序的，因为需要保证最终的结果一定是 c=a+b=3。

使用 volatile 关键字修饰共享变量可以禁止这种重排序。若用 volatile 修饰共享变量，在编译时，会在指令序列中插入**内存屏障**来禁止特定类型的处理器重排序，volatile 禁止指令重排序也有一些规则：

- 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
- 在进行指令优化时，不能将对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。

“也就是说，执行到 volatile 变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对 volatile 变量及其后面语句可见。”