---
layout: post
title: 左神算法视频笔记
subtitle: 
author: ezekielgcl
date: 2023-08-17
aliases: 
tags: 
keyword: 码农笔记
catalog: true
category: 码农笔记
status: 
link: 
BeginDate: 2023-08-17
EndDate: 
header-img: img/post-bg-re-vs-ng2.jpg
banner: "![[code6.jpeg]]"
banner_y: 0.40239
banner_icon: 📚
---


# 时间复杂度 空间复杂度


# ^异或运算
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817051832.png)

<mark style="background: #FF5582A6;">不同为 1，相同为 0</mark>

异或运算还可以理解为<mark style="background: #FF5582A6;">无进位相加</mark>
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817022547.png)


性质：
0 ^ n = n
n ^ n = 0

a ^ b = b ^ a
a ^ b ^ c = a ^ (b ^ c)



不使用中间变量，交换两个数a, b
a = a^b
b = a^b
a = a^b
```java
//这个方法的前提是 i不等于j,不然的话，这个位置就被抹成 0 了
public static void swap(int[] arr, int i, int j) {  
	arr[i] = arr[i] ^ arr[j];  
	arr[j] = arr[i] ^ arr[j];  
	arr[i] = arr[i] ^ arr[j];  
}
```


同一批数，进行异或运算，不管什么顺序，结果是一样的
算法题：
>1.一个数组中有一个数出现了奇数次，其他数都出现了偶数次，怎么找到这个数
>2.一个数组中有2个数出现了奇数次，其他数都出现了偶数次，怎么找到这2个数

参考：`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class01_02.Code02_EvenTimesOddTimes#printOddTimesNum2`

```java
	// arr中，有两种数，出现奇数次, 找出这两个数
	public static void printOddTimesNum2(int[] arr) {
		int eor = 0;
		for (int i = 0; i < arr.length; i++) {
			eor ^= arr[i];
		}
		// a 和 b是两种数 a!=b
		// 所以 eor != 0，  所以，eor至少有一位上是1，
		// 比如，假设第8位为1，那么a和b的第8位肯定不同，一个为1，另一个就为0，那么数组中的数就可以分成两类，一种是第8位为1的，另一种是第8位为0的
		// eor最右侧的1，提取出来
		// eor :     00110010110111000
		// rightOne :00000000000001000

		// eor :     			1010111100
		//~eor :     			0101000011
		//~eor + 1 :			0101000100
		//eor & (~eor + 1) : 	0000000100

		int rightOne = eor & (~eor + 1); // 提取出最右的1
		
		
		int onlyOne = 0; // eor'
		for (int i = 0 ; i < arr.length;i++) {
			//  arr[1] =  111100011110000
			// rightOne=  000000000010000
			if ((arr[i] & rightOne) != 0) {
				onlyOne ^= arr[i];
			}
		}
		System.out.println(onlyOne + " " + (eor ^ onlyOne));
	}

```


提取最右侧的 1
> 这是一个常规操作，如果要提取一个数最右侧的1，其他位都变为0，这么写就行了
```java
// eor :             1010111100  
//~eor :             0101000011  
//~eor + 1 :         0101000100  
//eor & (~eor + 1) : 0000000100
int rightOne = eor & (~eor + 1); // 提取出最右的1
```


# 简单排序
[[排序算法]]
## 冒泡排序

## 选择排序
## 快速排序
## 插入排序

对数器：
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817053026.png)

`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class01_01.Code03_InsertionSort#main`



# 二分查找
* 在一个有序数组中，找某个数是否存在

* 在一个有序数组中，找>=某个数最左侧的位置


* 局部最小值问题
数组arr，无序，相邻两个数一定不相等
对于左侧0位置，要满足`arr[0] < arr[1] `
对于右侧n-1位置，要满足`arr[n-1] < arr[n-2]`
对于i位置，要满足 `arr[i-1] > arr[i] 且 arr[i] < arr[i+1]`
求一个局部最小位置
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817051349.png)

![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817051544.png)

  
  
# 递归

![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817053439.png)

代码：
`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class02_03.Code08_GetMax#getMax`
```java
	// 求arr中的最大值
	public static int getMax(int[] arr) {
		return process(arr, 0, arr.length - 1);
	}

	// arr[L..R]范围上求最大值  L ... R   N
	public static int process(int[] arr, int L, int R) {
		// arr[L..R]范围上只有一个数，直接返回，base case
		if (L == R) { 
			return arr[L];
		}
		// L...R 不只一个数
		// mid = (L + R) / 2
		int mid = L + ((R - L) >> 1); // 中点   	1
		int leftMax = process(arr, L, mid);
		int rightMax = process(arr, mid + 1, R);
		return Math.max(leftMax, rightMax);
	}
```

![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817055022.png)



求中点
`mid = (L+R)/2` 这种写法有瑕疵，因为每种类型都是有长度方位的，L+R 可能会超范围
`mid = L + ((R - L) >> 1); // 中点正确写法`


# 归并排序
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817060544.png)
`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class03_04.Code01_MergeSort`


![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817063034.png)

# 堆
堆是完全二叉树结构，可以把数组从0出发的一段对应成完全二叉树
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817065728.png)


![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817065948.png)


## 大根堆
在这棵完全二叉树里，每一棵子树（从一个头结点出发，下面的子节点都要，这叫子树）的最大值就是头结点的值

![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817070515.png)

## 小根堆
同样，在这棵完全二叉树里，每一棵子树（从一个头结点出发，下面的子节点都要，这叫子树）的最小值就是头结点的值



代码：
`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class04_06.Code03_HeapSort`


//未完，待补充



# 链表
## 反转链表

## 打印公共部分
给定两个有序链表的头指针head1和head2，打印两个链表的公共部分
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817105818.png)


![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817105932.png)


![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817110051.png)




![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817110210.png)



![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817111345.png)


代码：
`com.guchaolong.algorithm.zuoshensuanfa.basic.class_03.Code_10_PrintCommonPart`


## 重要技巧
1. 额外数据结构记录（哈希表等）
2. 快慢指针


## 链表回文结构

代码：`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class06.Code02_IsPalindromeList`


![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817111830.png)

方法1：
最简单的，使用栈，遍历，把所有节点放到栈里面，栈里依次弹出的就是逆序的，然后和链表依次作对比
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817113022.png)


方法2：
改进上面的方法，只把右边部分放到栈里，那怎么找到右半边节点呢，答案就是快慢指针
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817113051.png)

<mark style="background: #FF5582A6;">慢指针一次走一步，快指针一次走两步，快指针走完的时候，慢指针来到中点位置</mark>
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817113303.png)

方法3：
方法1 2都是用了额外空间
方法3，使用快慢指针，慢指针S定位到中点后，把S后面的链表逆序，<mark style="background: #FF5582A6;">比方法1、2好</mark>，这是面试官想要的

![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817114316.png)



## 左边小 中间相等 右边大
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817115657.png)

代码：
`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class06.Code03_SmallerEqualBigger`


![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817120025.png)

遍历，4的时候，sh和st都为空，说明是第一个遇到的比5小的，然后sh和st都设为4...
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817120455.png)


遍历到3了，小于5，并且sh和st都不为null了，说明之前发现过小于5的节点
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817120711.png)


最好，小于区域的尾连等于区域的头，等于区域的尾连大于区域的头，搞定
（这里要考虑大于、小于、等于三个区域是否存在的问题）
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817120850.png)



## 复制含随机指针节点的链表
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817121444.png)

代码：
`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class06.Code04_CopyListWithRandom`

方法1：
使用哈希表，k为老节点，v为对应的克隆节点，

方法2：
不使用额外数据结构
克隆节点直接作为老节点的next，并且克隆节点的next指向老节点原来的next,克隆节点的random指针一律没设置
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817122902.png)


然后一对一对的来处理，设置新链表的random指针
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817123217.png)

最后，在next方向上，将新老链表分离出来


## 单链表相交问题
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817123553.png)
