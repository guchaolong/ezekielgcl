---
layout: post
title: 左神算法视频笔记
subtitle: 
author: ezekielgcl
date: 2023-08-17
aliases: 
tags: 
keyword: 码农笔记
catalog: true
category: 码农笔记
status: 
link: 
BeginDate: 2023-08-17
EndDate: 
header-img: img/post-bg-re-vs-ng2.jpg
banner: "![[code6.jpeg]]"
banner_y: 0.40239
banner_icon: 📚
---


# 时间复杂度 空间复杂度


# ^异或运算
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817051832.png)

<mark style="background: #FF5582A6;">不同为 1，相同为 0</mark>

异或运算还可以理解为<mark style="background: #FF5582A6;">无进位相加</mark>
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817022547.png)


性质：
0 ^ n = n
n ^ n = 0

a ^ b = b ^ a
a ^ b ^ c = a ^ (b ^ c)



不使用中间变量，交换两个数a, b
a = a^b
b = a^b
a = a^b
```java
//这个方法的前提是 i不等于j,不然的话，这个位置就被抹成 0 了
public static void swap(int[] arr, int i, int j) {  
	arr[i] = arr[i] ^ arr[j];  
	arr[j] = arr[i] ^ arr[j];  
	arr[i] = arr[i] ^ arr[j];  
}
```


同一批数，进行异或运算，不管什么顺序，结果是一样的
算法题：
>1.一个数组中有一个数出现了奇数次，其他数都出现了偶数次，怎么找到这个数
>2.一个数组中有2个数出现了奇数次，其他数都出现了偶数次，怎么找到这2个数

参考：`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class01_02.Code02_EvenTimesOddTimes#printOddTimesNum2`

```java
	// arr中，有两种数，出现奇数次, 找出这两个数
	public static void printOddTimesNum2(int[] arr) {
		int eor = 0;
		for (int i = 0; i < arr.length; i++) {
			eor ^= arr[i];
		}
		// a 和 b是两种数 a!=b
		// 所以 eor != 0，  所以，eor至少有一位上是1，
		// 比如，假设第8位为1，那么a和b的第8位肯定不同，一个为1，另一个就为0，那么数组中的数就可以分成两类，一种是第8位为1的，另一种是第8位为0的
		// eor最右侧的1，提取出来
		// eor :     00110010110111000
		// rightOne :00000000000001000

		// eor :     			1010111100
		//~eor :     			0101000011
		//~eor + 1 :			0101000100
		//eor & (~eor + 1) : 	0000000100

		int rightOne = eor & (~eor + 1); // 提取出最右的1
		
		
		int onlyOne = 0; // eor'
		for (int i = 0 ; i < arr.length;i++) {
			//  arr[1] =  111100011110000
			// rightOne=  000000000010000
			if ((arr[i] & rightOne) != 0) {
				onlyOne ^= arr[i];
			}
		}
		System.out.println(onlyOne + " " + (eor ^ onlyOne));
	}

```


提取最右侧的 1
> 这是一个常规操作，如果要提取一个数最右侧的1，其他位都变为0，这么写就行了
```java
// eor :             1010111100  
//~eor :             0101000011  
//~eor + 1 :         0101000100  
//eor & (~eor + 1) : 0000000100
int rightOne = eor & (~eor + 1); // 提取出最右的1
```


# 简单排序
[[排序算法]]
## 冒泡排序

## 选择排序
## 快速排序
## 插入排序

对数器：
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817053026.png)

`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class01_01.Code03_InsertionSort#main`



# 二分查找
* 在一个有序数组中，找某个数是否存在

* 在一个有序数组中，找>=某个数最左侧的位置


* 局部最小值问题
数组arr，无序，相邻两个数一定不相等
对于左侧0位置，要满足`arr[0] < arr[1] `
对于右侧n-1位置，要满足`arr[n-1] < arr[n-2]`
对于i位置，要满足 `arr[i-1] > arr[i] 且 arr[i] < arr[i+1]`
求一个局部最小位置
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817051349.png)

![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817051544.png)

  
  
# 递归

![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817053439.png)

代码：
`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class02_03.Code08_GetMax#getMax`
```java
	// 求arr中的最大值
	public static int getMax(int[] arr) {
		return process(arr, 0, arr.length - 1);
	}

	// arr[L..R]范围上求最大值  L ... R   N
	public static int process(int[] arr, int L, int R) {
		// arr[L..R]范围上只有一个数，直接返回，base case
		if (L == R) { 
			return arr[L];
		}
		// L...R 不只一个数
		// mid = (L + R) / 2
		int mid = L + ((R - L) >> 1); // 中点   	1
		int leftMax = process(arr, L, mid);
		int rightMax = process(arr, mid + 1, R);
		return Math.max(leftMax, rightMax);
	}
```

![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817055022.png)



求中点
`mid = (L+R)/2` 这种写法有瑕疵，因为每种类型都是有长度方位的，L+R 可能会超范围
`mid = L + ((R - L) >> 1); // 中点正确写法`


# 归并排序
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817060544.png)
`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class03_04.Code01_MergeSort`


![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817063034.png)

# 堆
堆是完全二叉树结构，可以把数组从0出发的一段对应成完全二叉树
![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817065728.png)


![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817065948.png)


## 大根堆
在这棵完全二叉树里，每一棵子树（从一个头结点出发，下面的子节点都要，这叫子树）的最大值就是头结点的值

![image.png](https://raw.githubusercontent.com/guchaolong/articleImgs/master/20230817070515.png)

## 小根堆
同样，在这棵完全二叉树里，每一棵子树（从一个头结点出发，下面的子节点都要，这叫子树）的最小值就是头结点的值



代码：
`com.guchaolong.algorithm.zuoshensuanfa.basic2020.class04_06.Code03_HeapSort`


//未完，待补充



# 链表

